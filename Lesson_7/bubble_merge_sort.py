'''
Тут обе задачи вместе, для наглядности сравнения

---
Задание 1:
Отсортируйте по убыванию методом "пузырька" одномерный целочисленный массив, заданный случайными числами на
промежутке [-100; 100). Выведите на экран исходный и отсортированный массивы. Сортировка должна быть реализована в
виде функции. По возможности доработайте алгоритм (сделайте его умнее).
---

Берем, собственно, и реализуем классическую сортировку методом пузырька внутри двух циклов.
Количество проходов равно количеству элементов массива за вычетом единицы, т.к. происходит попарное сравнение.

При первом проходе по массиву при сортировке по убыванию последним в массиве оказывается наименьшее число, на следующем
проходе - наименьшее из оставшихся. Так что количество "пройденных" элементов можно уменьшать на один при каждом проходе

---
Задание 2:
Отсортируйте по возрастанию методом слияния одномерный вещественный массив, заданный случайными числами на
промежутке [0; 50). Выведите на экран исходный и отсортированный массивы.
---

Чтобы два раза не бегать (за генерацией массива) - реализуем этот метод в виде еще одной функции прямо тут (точнее в
виде двух функций: merge и merge_sort). Для наглядности, в merge_sort мы реализуем логику "разрезания" массива на две
части с рекурсивным вызовом merge (мозг все равно взрывает). Внутри merge мы поочередно берем первое значение из левой
и правой части, сравниваем и добавляем в итоговый список наибольшее из них. Оставшийся "хвостик" приклеиваем к
итоговому списку. Таким образом получается, что каждый раз, по рекурсии мы проваливаемся вниз, пока не разобьем на атомы

Для удобства экспериментов - сделаем еще функцию генерации исходных массивов. Передаем в нее минимальное и максимальное
значения, а также тип значений (целое или вещественное). Я намеренно вынес длинну массива в константу, чтобы ставить там
значения, достаточные для наглядной разницы в производительности. Уже на 10000 элементов сортировка слиянием существенно
обгоняет сортировку пузырьком (78 ms против 10472 ms)
'''

import random
import time

N = 10000  # константа длинны массива


def gen_array(min_value, max_value, array_type="int"):
    a = [0] * N

    if array_type == "int":
        for i in range(N):
            a[i] = random.randint(min_value, max_value)
    elif array_type == "float":
        for i in range(N):
            a[i] = random.uniform(min_value, max_value)
    else:
        print("Incorrect type of value")
    return a


def bubble_sort(array):
    for i in range(N - 1):
        for j in range(N - 1 - i):
            if array[j] < array[j + 1]:
                array[j], array[j + 1] = array[j + 1], array[j]
    return array


def merge(left, right):
    lst = []
    while left and right:
        if left[0] < right[0]:
            lst.append(left.pop(0))
        else:
            lst.append(right.pop(0))
    if left:
        lst.extend(left)
    if right:
        lst.extend(right)
    return lst


def merge_sort(array):
    length = len(array)
    if length >= 2:
        mid = int(length / 2)
        array = merge(merge_sort(array[:mid]), merge_sort(array[mid:]))
    return array


def main():
    cur_time = time.time()
    print("--- Bubble Sort Test ---")
    a = gen_array(-100, 100, "int")
    print(a)
    print(bubble_sort(a))
    print("Time(ms) =", int((time.time()-cur_time)*1000))

    cur_time = time.time()
    print("--- Merge Sort Test ---")
    a = gen_array(0, 50, "float")
    print(a)
    print(merge_sort(a))
    print("Time(ms) =", int((time.time()-cur_time)*1000))


if __name__ == '__main__':
    main()
